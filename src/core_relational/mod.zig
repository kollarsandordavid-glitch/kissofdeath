const std = @import("std");

pub const nsir_core = @import("nsir_core.zig");
pub const quantum_logic = @import("quantum_logic.zig");
pub const z_runtime = @import("z_runtime.zig");
pub const chaos_core = @import("chaos_core.zig");
pub const r_gpu = @import("r_gpu.zig");
pub const esso_optimizer = @import("esso_optimizer.zig");
pub const crev_pipeline = @import("crev_pipeline.zig");
pub const fnds = @import("fnds.zig");
pub const temporal_graph = @import("temporal_graph.zig");
pub const c_api = @import("c_api.zig");
pub const vpu = @import("vpu.zig");
pub const formal_verification = @import("formal_verification.zig");
pub const security_proofs = @import("security_proofs.zig");
pub const type_theory = @import("type_theory.zig");
pub const quantum_hardware = @import("quantum_hardware.zig");
pub const ibm_quantum = @import("ibm_quantum.zig");
pub const quantum_task_adapter = @import("quantum_task_adapter.zig");
pub const reasoning_orchestrator = @import("reasoning_orchestrator.zig");
pub const safety = @import("safety.zig");
pub const signal_propagation = @import("signal_propagation.zig");
pub const surprise_memory = @import("surprise_memory.zig");
pub const verified_inference_engine = @import("verified_inference_engine.zig");
pub const zk_verification = @import("zk_verification.zig");
pub const dataset_obfuscation = @import("dataset_obfuscation.zig");

pub const SelfSimilarRelationalGraph = nsir_core.SelfSimilarRelationalGraph;
pub const Node = nsir_core.Node;
pub const Edge = nsir_core.Edge;
pub const EdgeQuality = nsir_core.EdgeQuality;
pub const EdgeKey = nsir_core.EdgeKey;
pub const EdgeKeyContext = nsir_core.EdgeKeyContext;
pub const Complex = std.math.Complex;
pub const hadamardGate = nsir_core.hadamardGate;
pub const pauliXGate = nsir_core.pauliXGate;
pub const pauliYGate = nsir_core.pauliYGate;
pub const pauliZGate = nsir_core.pauliZGate;
pub const phaseGate = nsir_core.phaseGate;
pub const identityGate = nsir_core.identityGate;

pub const RelationalQuantumLogic = quantum_logic.RelationalQuantumLogic;
pub const QuantumState = quantum_logic.QuantumState;
pub const LogicGate = quantum_logic.LogicGate;
pub const GateHistoryEntry = quantum_logic.GateHistoryEntry;
pub const QuantumCircuit = quantum_logic.QuantumCircuit;
pub const MeasurementResult = quantum_logic.MeasurementResult;

pub const ZRuntime = z_runtime.ZRuntime;
pub const ZVariable = z_runtime.ZVariable;
pub const HistoryEntry = z_runtime.HistoryEntry;
pub const HistoryEntryType = z_runtime.HistoryEntryType;
pub const ExecutionHistoryEntry = z_runtime.ExecutionHistoryEntry;
pub const ExecutionAction = z_runtime.ExecutionAction;
pub const RelationalOperationType = z_runtime.RelationalOperationType;
pub const SystemState = z_runtime.SystemState;
pub const VariableState = z_runtime.VariableState;
pub const GateSpec = z_runtime.GateSpec;

pub const ChaosCoreKernel = chaos_core.ChaosCoreKernel;
pub const ContentAddressableStorage = chaos_core.ContentAddressableStorage;
pub const DynamicTaskScheduler = chaos_core.DynamicTaskScheduler;
pub const DataFlowAnalyzer = chaos_core.DataFlowAnalyzer;
pub const MemoryBlock = chaos_core.MemoryBlock;
pub const MemoryBlockState = chaos_core.MemoryBlockState;
pub const TaskDescriptor = chaos_core.TaskDescriptor;
pub const ChaosProcessingCore = chaos_core.ProcessingCore;
pub const ChaosCoreState = chaos_core.CoreState;
pub const StorageStatistics = chaos_core.StorageStatistics;
pub const SchedulerStatistics = chaos_core.SchedulerStatistics;
pub const KernelStatistics = chaos_core.KernelStatistics;

pub const RelationalGraphProcessingUnit = r_gpu.RelationalGraphProcessingUnit;
pub const AsynchronousNoC = r_gpu.AsynchronousNoC;
pub const RGPUProcessingCore = r_gpu.ProcessingCore;
pub const RGPUCoreState = r_gpu.CoreState;
pub const NoCMessage = r_gpu.NoCMessage;
pub const MessageType = r_gpu.MessageType;
pub const GraphIsomorphismProcessor = r_gpu.GraphIsomorphismProcessor;
pub const DynamicEdgeWeighting = r_gpu.DynamicEdgeWeighting;
pub const SparseActivationManager = r_gpu.SparseActivationManager;
pub const PowerGatingController = r_gpu.PowerGatingController;
pub const RPGUStatistics = r_gpu.RPGUStatistics;
pub const RouteKey = r_gpu.RouteKey;

pub const EntangledStochasticSymmetryOptimizer = esso_optimizer.EntangledStochasticSymmetryOptimizer;
pub const EssoOptimizationState = esso_optimizer.OptimizationState;
pub const EssoOptimizationStatistics = esso_optimizer.OptimizationStatistics;
pub const SymmetryGroup = esso_optimizer.SymmetryGroup;
pub const SymmetryPattern = esso_optimizer.SymmetryPattern;
pub const EntanglementInfo = esso_optimizer.EntanglementInfo;
pub const ObjectiveFunction = esso_optimizer.ObjectiveFunction;
pub const defaultGraphObjective = esso_optimizer.defaultGraphObjective;
pub const connectivityObjective = esso_optimizer.connectivityObjective;
pub const quantumCoherenceObjective = esso_optimizer.quantumCoherenceObjective;
pub const fractalDimensionObjective = esso_optimizer.fractalDimensionObjective;

pub const CREVPipeline = crev_pipeline.CREVPipeline;
pub const ExtractionStage = crev_pipeline.ExtractionStage;
pub const RelationalTriplet = crev_pipeline.RelationalTriplet;
pub const ValidationResult = crev_pipeline.ValidationResult;
pub const KnowledgeGraphIndex = crev_pipeline.KnowledgeGraphIndex;
pub const StreamBuffer = crev_pipeline.StreamBuffer;
pub const PipelineResult = crev_pipeline.PipelineResult;
pub const PipelineStatistics = crev_pipeline.PipelineStatistics;
pub const TripletIndex = crev_pipeline.TripletIndex;
pub const RelationPattern = crev_pipeline.RelationPattern;
pub const TokenizerConfig = crev_pipeline.TokenizerConfig;

pub const FNDSManager = fnds.FNDSManager;
pub const FNDSStatistics = fnds.FNDSStatistics;
pub const FractalLevel = fnds.FractalLevel;
pub const FractalTree = fnds.FractalTree;
pub const FractalNodeData = fnds.FractalNodeData;
pub const FractalEdgeData = fnds.FractalEdgeData;
pub const SelfSimilarIndex = fnds.SelfSimilarIndex;
pub const PatternLocation = fnds.PatternLocation;
pub const LRUCache = fnds.LRUCache;
pub const LRUCacheEntry = fnds.LRUCacheEntry;
pub const TraversalOrder = fnds.TraversalOrder;
pub const TraversalCallback = fnds.TraversalCallback;

pub const TemporalGraph = temporal_graph.TemporalGraph;
pub const TemporalNode = temporal_graph.TemporalNode;
pub const TemporalEdge = temporal_graph.TemporalEdge;
pub const NodeVersion = temporal_graph.NodeVersion;
pub const EdgeVersion = temporal_graph.EdgeVersion;
pub const GraphSnapshot = temporal_graph.GraphSnapshot;
pub const TemporalQuery = temporal_graph.TemporalQuery;
pub const TemporalQueryResult = temporal_graph.TemporalQueryResult;
pub const TemporalHistoryEntry = temporal_graph.HistoryEntry;
pub const Timestamp = temporal_graph.Timestamp;
pub const NodeFilterFn = temporal_graph.NodeFilterFn;
pub const EdgeFilterFn = temporal_graph.EdgeFilterFn;
pub const getCurrentTimestamp = temporal_graph.getCurrentTimestamp;
pub const timestampToMillis = temporal_graph.timestampToMillis;
pub const millisToTimestamp = temporal_graph.millisToTimestamp;
pub const timestampToSeconds = temporal_graph.timestampToSeconds;
pub const secondsToTimestamp = temporal_graph.secondsToTimestamp;
pub const defaultNodeFilter = temporal_graph.defaultNodeFilter;
pub const defaultEdgeFilter = temporal_graph.defaultEdgeFilter;
pub const filterByEntanglement = temporal_graph.filterByEntanglement;
pub const filterBySuperposition = temporal_graph.filterBySuperposition;
pub const filterByCoherence = temporal_graph.filterByCoherence;

pub const VPU = vpu.VPU;
pub const VPUStatistics = vpu.VPUStatistics;
pub const VectorType = vpu.VectorType;
pub const SimdVector = vpu.SimdVector;
pub const F32x4 = vpu.F32x4;
pub const F32x8 = vpu.F32x8;
pub const F64x2 = vpu.F64x2;
pub const F64x4 = vpu.F64x4;
pub const I32x4 = vpu.I32x4;
pub const I32x8 = vpu.I32x8;
pub const VectorBatch = vpu.VectorBatch;
pub const VectorBatchEntry = vpu.VectorBatchEntry;
pub const BatchOperation = vpu.BatchOperation;
pub const Matrix4x4 = vpu.Matrix4x4;
pub const MatrixOps = vpu.MatrixOps;
pub const RelationalVectorOps = vpu.RelationalVectorOps;
pub const MemoryPool = vpu.MemoryPool;
pub const MemorySlice = vpu.MemorySlice;
pub const VectorCache = vpu.VectorCache;
pub const LNSValue = vpu.LNSValue;
pub const LNSInstruction = vpu.LNSInstruction;

pub const CQuantumState = c_api.CQuantumState;
pub const CNode = c_api.CNode;
pub const CEdge = c_api.CEdge;
pub const CGraph = c_api.CGraph;
pub const COptimizer = c_api.COptimizer;
pub const CApiOptimizationStatistics = c_api.OptimizationStatistics;
pub const CApiOptimizer = c_api.EntangledStochasticSymmetryOptimizer;

pub const JAIDE_SUCCESS = c_api.JAIDE_SUCCESS;
pub const JAIDE_ERROR_NULL_POINTER = c_api.JAIDE_ERROR_NULL_POINTER;
pub const JAIDE_ERROR_ALLOCATION = c_api.JAIDE_ERROR_ALLOCATION;
pub const JAIDE_ERROR_NODE_NOT_FOUND = c_api.JAIDE_ERROR_NODE_NOT_FOUND;
pub const JAIDE_ERROR_EDGE_NOT_FOUND = c_api.JAIDE_ERROR_EDGE_NOT_FOUND;
pub const JAIDE_ERROR_INVALID_QUALITY = c_api.JAIDE_ERROR_INVALID_QUALITY;
pub const JAIDE_ERROR_OPTIMIZATION_FAILED = c_api.JAIDE_ERROR_OPTIMIZATION_FAILED;
pub const JAIDE_ERROR_INVALID_STRING = c_api.JAIDE_ERROR_INVALID_STRING;
pub const JAIDE_ERROR_OPERATION_FAILED = c_api.JAIDE_ERROR_OPERATION_FAILED;

pub const jaide_create_graph = c_api.jaide_create_graph;
pub const jaide_destroy_graph = c_api.jaide_destroy_graph;
pub const jaide_graph_node_count = c_api.jaide_graph_node_count;
pub const jaide_graph_edge_count = c_api.jaide_graph_edge_count;
pub const jaide_add_node = c_api.jaide_add_node;
pub const jaide_remove_node = c_api.jaide_remove_node;
pub const jaide_get_node_quantum_state = c_api.jaide_get_node_quantum_state;
pub const jaide_set_node_quantum_state = c_api.jaide_set_node_quantum_state;
pub const jaide_add_edge = c_api.jaide_add_edge;
pub const jaide_remove_edge = c_api.jaide_remove_edge;
pub const jaide_get_edge_weight = c_api.jaide_get_edge_weight;
pub const jaide_set_edge_quality = c_api.jaide_set_edge_quality;
pub const jaide_apply_hadamard = c_api.jaide_apply_hadamard;
pub const jaide_apply_pauli_x = c_api.jaide_apply_pauli_x;
pub const jaide_apply_pauli_y = c_api.jaide_apply_pauli_y;
pub const jaide_apply_pauli_z = c_api.jaide_apply_pauli_z;
pub const jaide_entangle_nodes = c_api.jaide_entangle_nodes;
pub const jaide_measure_node = c_api.jaide_measure_node;
pub const jaide_create_optimizer = c_api.jaide_create_optimizer;
pub const jaide_destroy_optimizer = c_api.jaide_destroy_optimizer;
pub const jaide_optimize_graph = c_api.jaide_optimize_graph;
pub const jaide_get_fractal_dimension = c_api.jaide_get_fractal_dimension;
pub const jaide_get_topology_hash = c_api.jaide_get_topology_hash;
pub const jaide_encode_information = c_api.jaide_encode_information;
pub const jaide_decode_information = c_api.jaide_decode_information;
pub const jaide_has_node = c_api.jaide_has_node;
pub const jaide_has_edge = c_api.jaide_has_edge;
pub const jaide_clear_graph = c_api.jaide_clear_graph;
pub const jaide_get_node_phase = c_api.jaide_get_node_phase;
pub const jaide_set_node_phase = c_api.jaide_set_node_phase;
pub const jaide_get_edge_quality = c_api.jaide_get_edge_quality;
pub const jaide_get_node_data = c_api.jaide_get_node_data;
pub const jaide_set_edge_weight = c_api.jaide_set_edge_weight;
pub const jaide_get_edge_fractal_dimension = c_api.jaide_get_edge_fractal_dimension;
pub const jaide_set_edge_fractal_dimension = c_api.jaide_set_edge_fractal_dimension;
pub const jaide_set_optimizer_min_temperature = c_api.jaide_set_optimizer_min_temperature;
pub const jaide_set_optimizer_adaptive_cooling = c_api.jaide_set_optimizer_adaptive_cooling;
pub const jaide_set_optimizer_reheat_params = c_api.jaide_set_optimizer_reheat_params;
pub const jaide_get_optimizer_statistics = c_api.jaide_get_optimizer_statistics;
pub const jaide_get_node_probability = c_api.jaide_get_node_probability;
pub const jaide_get_node_magnitude = c_api.jaide_get_node_magnitude;
pub const jaide_get_edge_correlation_magnitude = c_api.jaide_get_edge_correlation_magnitude;
pub const jaide_apply_identity_gate = c_api.jaide_apply_identity_gate;
pub const jaide_version_major = c_api.jaide_version_major;
pub const jaide_version_minor = c_api.jaide_version_minor;
pub const jaide_version_patch = c_api.jaide_version_patch;

pub const FormalVerificationEngine = formal_verification.FormalVerificationEngine;
pub const InvariantType = formal_verification.InvariantType;
pub const ProofRule = formal_verification.ProofRule;
pub const PropType = formal_verification.PropType;
pub const Proposition = formal_verification.Proposition;
pub const ProofStep = formal_verification.ProofStep;
pub const FormalProof = formal_verification.FormalProof;
pub const Invariant = formal_verification.Invariant;
pub const InvariantRegistry = formal_verification.InvariantRegistry;
pub const InvariantStatistics = formal_verification.InvariantStatistics;
pub const HoareTriple = formal_verification.HoareTriple;
pub const HoareLogicVerifier = formal_verification.HoareLogicVerifier;
pub const HoareStatistics = formal_verification.HoareStatistics;
pub const TheoremProver = formal_verification.TheoremProver;
pub const ProverStatistics = formal_verification.ProverStatistics;
pub const Term = formal_verification.Term;
pub const Substitution = formal_verification.Substitution;
pub const Clause = formal_verification.Clause;
pub const ProofTreeNode = formal_verification.ProofTreeNode;
pub const VerificationError = formal_verification.VerificationError;
pub const FormalVerificationResult = formal_verification.VerificationResult;
pub const EngineStatistics = formal_verification.EngineStatistics;
pub const PredicateFn = formal_verification.PredicateFn;

pub const SecurityError = security_proofs.SecurityError;
pub const SecurityLevel = security_proofs.SecurityLevel;
pub const IntegrityLevel = security_proofs.IntegrityLevel;
pub const AccessRight = security_proofs.AccessRight;
pub const AccessRightSet = security_proofs.AccessRightSet;
pub const SecurityCategory = security_proofs.SecurityCategory;
pub const SecurityLabel = security_proofs.SecurityLabel;
pub const Principal = security_proofs.Principal;
pub const SecureObject = security_proofs.SecureObject;
pub const FlowEdge = security_proofs.FlowEdge;
pub const FlowGraph = security_proofs.FlowGraph;
pub const InformationFlowLattice = security_proofs.InformationFlowLattice;
pub const IllegalFlow = security_proofs.IllegalFlow;
pub const FlowProofStep = security_proofs.FlowProofStep;
pub const InformationFlowAnalysis = security_proofs.InformationFlowAnalysis;
pub const SecuritySystemState = security_proofs.SystemState;
pub const NonInterferenceProperty = security_proofs.NonInterferenceProperty;
pub const BisimulationRelation = security_proofs.BisimulationRelation;
pub const NonInterferenceProofStep = security_proofs.NonInterferenceProofStep;
pub const NonInterferenceProver = security_proofs.NonInterferenceProver;
pub const AccessControlPolicy = security_proofs.AccessControlPolicy;
pub const AccessRule = security_proofs.AccessRule;
pub const AccessControlMatrix = security_proofs.AccessControlMatrix;
pub const AccessProofStep = security_proofs.AccessProofStep;
pub const SeparationOfDutiesConstraint = security_proofs.SeparationOfDutiesConstraint;
pub const AccessControlVerifier = security_proofs.AccessControlVerifier;
pub const HashChainBlock = security_proofs.HashChainBlock;
pub const HashChain = security_proofs.HashChain;
pub const MerkleNode = security_proofs.MerkleNode;
pub const MerkleProof = security_proofs.MerkleProof;
pub const MerkleTree = security_proofs.MerkleTree;
pub const Commitment = security_proofs.Commitment;
pub const CommitmentScheme = security_proofs.CommitmentScheme;
pub const CryptographicProof = security_proofs.CryptographicProof;
pub const BellLaPadula = security_proofs.BellLaPadula;
pub const Biba = security_proofs.Biba;
pub const IntegrityVerifier = security_proofs.IntegrityVerifier;
pub const SecurityProofType = security_proofs.SecurityProofType;
pub const SecurityProofStep = security_proofs.SecurityProofStep;
pub const SecurityProof = security_proofs.SecurityProof;
pub const SecurityProofEngine = security_proofs.SecurityProofEngine;

pub const TypeTheoryError = type_theory.TypeTheoryError;
pub const TypeKind = type_theory.TypeKind;
pub const RecordField = type_theory.RecordField;
pub const Type = type_theory.Type;
pub const TypeBinding = type_theory.TypeBinding;
pub const TypeContext = type_theory.TypeContext;
pub const TermKind = type_theory.TermKind;
pub const TypeTheoryTerm = type_theory.Term;
pub const TypeJudgment = type_theory.TypeJudgment;
pub const DependentPi = type_theory.DependentPi;
pub const DependentSigma = type_theory.DependentSigma;
pub const IdentityType = type_theory.IdentityType;
pub const UniverseType = type_theory.UniverseType;
pub const InductiveType = type_theory.InductiveType;
pub const TypeChecker = type_theory.TypeChecker;
pub const TypeCheckerStatistics = type_theory.TypeCheckerStatistics;
pub const LogicalConnective = type_theory.LogicalConnective;
pub const PropositionAsType = type_theory.PropositionAsType;
pub const ProofTerm = type_theory.ProofTerm;
pub const CategoryObject = type_theory.CategoryObject;
pub const Morphism = type_theory.Morphism;
pub const Category = type_theory.Category;
pub const Functor = type_theory.Functor;
pub const NaturalTransformation = type_theory.NaturalTransformation;
pub const Monad = type_theory.Monad;
pub const CartesianClosedCategory = type_theory.CartesianClosedCategory;
pub const LinearityMode = type_theory.LinearityMode;
pub const LinearType = type_theory.LinearType;
pub const ResourceUsage = type_theory.ResourceUsage;
pub const LinearTypeChecker = type_theory.LinearTypeChecker;
pub const LinearCheckerStatistics = type_theory.LinearCheckerStatistics;
pub const TypeProofKind = type_theory.TypeProofKind;
pub const TypeProof = type_theory.TypeProof;
pub const ProofResult = type_theory.ProofResult;
pub const TypeTheoryEngine = type_theory.TypeTheoryEngine;
pub const TypeTheoryStatistics = type_theory.TypeTheoryStatistics;

pub const IBMQuantumCredentials = quantum_hardware.IBMQuantumCredentials;
pub const QuantumBackendType = quantum_hardware.QuantumBackendType;
pub const QuantumBackend = quantum_hardware.QuantumBackend;
pub const BackendStatus = quantum_hardware.BackendStatus;
pub const QuantumGateOp = quantum_hardware.QuantumGateOp;
pub const QuantumInstruction = quantum_hardware.QuantumInstruction;
pub const QuantumCondition = quantum_hardware.QuantumCondition;
pub const HardwareQuantumCircuit = quantum_hardware.QuantumCircuit;
pub const JobStatus = quantum_hardware.JobStatus;
pub const QuantumJob = quantum_hardware.QuantumJob;
pub const CountResult = quantum_hardware.CountResult;
pub const QuantumResult = quantum_hardware.QuantumResult;
pub const ErrorMitigationMethod = quantum_hardware.ErrorMitigationMethod;
pub const ErrorMitigationConfig = quantum_hardware.ErrorMitigationConfig;
pub const DDSequence = quantum_hardware.DDSequence;
pub const SamplerOptions = quantum_hardware.SamplerOptions;
pub const EstimatorOptions = quantum_hardware.EstimatorOptions;
pub const ZNEExtrapolator = quantum_hardware.ZNEExtrapolator;
pub const Observable = quantum_hardware.Observable;
pub const ExpectationValue = quantum_hardware.ExpectationValue;
pub const IBMQuantumClient = quantum_hardware.IBMQuantumClient;
pub const QuantumClientStatistics = quantum_hardware.QuantumClientStatistics;
pub const QuantumClassicalHybridOptimizer = quantum_hardware.QuantumClassicalHybridOptimizer;

test "core_relational module integration" {
    const allocator = std.testing.allocator;

    var runtime = try ZRuntime.init(allocator);
    defer runtime.deinit();

    const var1 = try runtime.createVariable("x", "hello");
    _ = var1;

    const var2 = try runtime.createVariable("y", "world");
    _ = var2;

    _ = try runtime.entangleVariables("x", "y");

    try std.testing.expect(runtime.variableCount() == 2);

    var kernel = ChaosCoreKernel.init(allocator);
    defer kernel.deinit();

    const block_id = kernel.allocateMemory("test data", null) catch unreachable;
    const retrieved = kernel.readMemory(block_id);
    try std.testing.expect(retrieved != null);

    try std.testing.expect(kernel.cycle_count == 0);
}
